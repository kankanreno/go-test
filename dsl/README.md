
# 词法分析器

## 前言

使用Go语言实现一个DSL的词法分析器，要求能处理if、else、return、for等关键字，并且变量以$为前缀。

### 词法分析的基本概念

词法分析器（Lexer）的任务是将输入的字符串分解成一系列的标记（Token），每个标记代表代码中的一个有意义的单元，比如关键字、变量、数字、运算符等。在Go中，通常使用正则表达式来匹配不同的Token模式，并按顺序逐个提取。

### 用户的需求

处理常见的关键字，如if、else、return、for，同时变量以$开头，比如$var。我需要考虑如何正确识别这些Token，特别是变量和关键字的区分。例如，用户可能不希望将$if识别为关键字if，而是作为变量处理，所以需要确保正则表达式的顺序，变量的正则表达式在关键字之前，或者关键字有更高的优先级。

### Token的类型设计

常见的关键字如if、else等需要各自对应的Token类型，比如TokenIf、TokenElse等。变量则需要一个单独的Token类型，比如TokenVariable，用来表示以$开头的变量。此外，还需要处理数字、字符串、运算符、括号等基本元素。

### 正则表达式的编写

正则表达式的编写是词法分析的关键。需要确保关键字的正则表达式能够准确匹配，同时变量以$开头，后面跟随字母或下划线，然后是字母、数字、下划线的组合。例如，变量可能被匹配为\$[a-zA-Z_][a-zA-Z0-9_]*。

需要注意的是，正则表达式的顺序很重要，因为Go的regexp库在匹配时是按照给定的顺序进行的，所以应该将更具体的模式放在前面，比如关键字应该在标识符之前，否则关键字可能会被识别为标识符。

例如，如果用户写了一个if语句，词法分析器应该将其识别为TokenIf，而不是一个标识符。因此，在正则表达式列表中，关键字的正则表达式应该在标识符的正则表达式之前。同样，变量的正则表达式应该在标识符之前，因为变量以$开头，而标识符可能没有，这样就不会冲突。

### 处理空格和注释

空格通常会被跳过，注释（比如单行注释或多行注释）也需要在词法分析器中处理，避免它们干扰其他Token的识别。

### Lexer的结构与错误处理

考虑如何构建Lexer的结构。可能需要维护当前的位置信息，以及输入字符串的剩余部分。逐个字符扫描，使用正则表达式匹配最长的可能Token，然后前进相应的位置。

对于错误处理，当遇到无法识别的字符时，应该返回错误信息，指出位置和原因，比如非法的字符。

### 代码结构大致如下：

- 定义TokenType常量，包括各种关键字、变量、运算符等。
- 创建tokenPatterns列表，每个元素包含正则表达式和对应的TokenType，注意顺序。
- Lex函数循环处理输入字符串，逐个匹配Token，生成Token列表。
- 跳过空格和注释。
- 处理变量时，提取变量名（去掉$符号），并存储为TokenVariable类型。

### 注意

在实现过程中，需要注意正则表达式的编写是否正确，例如变量的正则表达式是否以$开头，后面是否有合法的字符。同时，确保关键字如if、else等不会被错误地匹配为变量或标识符。

测试用例也是必要的，例如测试一个包含if语句和变量的输入，验证生成的Token列表是否正确，包括Token类型和值。

可能的错误点包括正则表达式顺序错误，导致变量或关键字未被正确识别；或者变量的正则表达式捕获组不正确，导致提取的变量名包含$符号。需要确保在匹配变量时，正则表达式捕获的是变量名部分，而不是包括$符号。

最后，需要提供一个示例，展示如何使用这个Lexer，比如输入一段DSL代码，输出对应的Token列表，并验证变量是否正确识别，关键字如if是否被正确标记。

## 关键特性说明

### 优先级处理：

关键字识别优先于普通标识符（通过正则表达式顺序控制）
多字符运算符（如 ==, !=）优先于单字符运算符

### 变量处理：

使用 \$[a-zA-Z_][a-zA-Z0-9_]* 匹配 $ 开头的变量
示例：$count → TokenVariable("$count")

### 注释处理：

支持单行注释和多行注释
在词法分析阶段直接跳过

### 字符串处理：

支持双引号字符串 "hello world"
自动去除引号（Token 中只保留内容）

### 错误处理：

遇到无法识别的字符时返回 TokenError
包含错误位置信息

## 示例输出片段：

[   5] IF         "if"
[   8] (          "("
[   9] VARIABLE   "$count"
[  15] >          ">"
[  17] NUMBER     "5"
...
[  36] VARIABLE   "$result"
[  43] *          "*"
[  45] NUMBER     "2"

## 扩展建议

### 添加更多数据类型：

// 支持十六进制
{regexp.MustCompile(`^0x[0-9a-fA-F]+`), TokenNumber},

// 支持科学计数法
{regexp.MustCompile(`^\d+\.?\d*([eE][+-]?\d+)?`), TokenNumber},

### 增强错误信息：

// 在错误 Token 中记录更多上下文
errorValue := fmt.Sprintf("Unexpected char '%c' at position %d",
input[pos], pos)

### 支持更多运算符：

{regexp.MustCompile(`^>=`), TokenGe},
{regexp.MustCompile(`^<=`), TokenLe},
{regexp.MustCompile(`^&&`), TokenAnd},

这个实现可以作为 DSL 解析器的基础，后续可以结合语法解析器构建完整的 AST。

# 语法解析器

## 前言

实现一个语法解析器，配合之前完成的词法分析器，能处理if、else、return、for等关键字，以及以$开头的变量，将词法分析后的Token流转换为抽象语法树（AST）。

### AST节点设计

语法解析器通常使用递归下降法，尤其是对于像这样的简单DSL。递归下降比较直观，容易实现，适合手写解析器。需要根据常见的语法结构来设计AST的节点类型，比如表达式、语句、函数声明等。

然后，用户给出的示例代码中有一些结构，比如if语句、for循环、变量声明等。我需要定义这些结构对应的AST节点。比如，IfStmt需要包含条件表达式、Then分支和Else分支，ForStmt需要初始化、条件、后续步骤和循环体。

接下来，处理运算符优先级和结合性的问题。在表达式中，乘除应该比加减优先级高，比较运算符如>、<等优先级较低。可能需要使用递归下降中的分层方法，比如不同层级的parse函数处理不同优先级的运算符。

然后，我需要处理词法分析器产生的Token类型，比如识别变量、数字、字符串，以及各种运算符。同时，需要处理关键字，如if、else、return、for，将它们转换为对应的语法结构。

### 注意

在实现解析器时，需要注意错误处理，当遇到不符合语法的Token时，能给出有意义的错误信息。可能需要一个peek函数来查看下一个Token，而consume函数用来消费当前Token并前进到下一个。

### 组织代码

可能的结构包括：定义AST节点结构体，如Expr、Stmt的各种子类型，然后编写解析函数，如parseStmt、parseExpr、parseIfStmt、parseForStmt等。

对于表达式解析，可能需要按照优先级从高到低处理。例如，先处理括号内的表达式，然后是乘除，再是加减，接着是比较运算符，最后是赋值等。每个优先级层次对应一个函数，如parsePrimaryExpr处理变量、字面量，parseMulExpr处理乘除，parseAddExpr处理加减，parseCompare处理比较，parseAssign处理赋值等。

在处理语句时，例如if语句，需要匹配if关键字，然后解析条件表达式，接着解析块语句（用大括号包裹的语句列表），以及可选的else分支。类似地，for循环需要解析初始化、条件、后续步骤和循环体。

还需要处理块语句，即由大括号包裹的多个语句。这可能需要parseBlock函数，处理左大括号，然后循环解析语句直到遇到右大括号。

在变量声明和赋值方面，可能需要处理以$开头的变量，作为左值出现在赋值语句的左边。例如，$sum = $sum + $i 应该被解析为一个赋值语句，其中左值是变量$sum，右值是一个加法表达式。

此外，return语句需要解析return关键字后面的表达式，作为返回值。

### 测试

在测试方面，需要用示例代码来验证解析器是否能正确生成AST。例如，用户提供的示例输入中的if-else和for循环结构是否被正确解析为相应的节点。

可能遇到的问题包括：运算符优先级的处理错误，导致表达式结构不正确；括号嵌套处理不当；或者语句结构解析错误，如if后面缺少条件表达式。这时需要仔细检查递归下降的各个函数，确保按照正确的语法规则进行解析。

### 其他

另外，需要确保词法分析器和语法解析器之间的接口正确，比如Token的Type和Value被正确传递，位置信息用于错误报告。

最后，可能需要考虑扩展性，比如未来添加新的语法结构时，如何方便地扩展AST节点和解析函数。代码结构清晰，模块化设计会有助于后续的维护和扩展。

综上所述，步骤大致是：设计AST节点结构，编写解析函数处理不同的语法结构，处理表达式优先级，实现错误处理，测试验证。
